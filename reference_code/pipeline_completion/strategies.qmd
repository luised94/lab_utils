# Create a key column to subset dataframe with another set of keys
```{r}
# Create the metadata characters and keys for sample and bigwig comparisons (_SB)
METADATA_CHARACTER_VECTORS_SB <- lapply(final_metadata[c("sample", "bigwig_processing")], as.character)
METADATA_JOINED_KEYS_SB <- do.call(paste, c(METADATA_CHARACTER_VECTORS_SB, sep = METADATA_COLUMN_SEPARATOR))

CONTROL_BAM_COMBINATIONS_CHARACTERS <- lapply(VALID_BAM_PROCESSING_COMBINATIONS, as.character)
control_joined_keys <- do.call(paste, c(CONTROL_BAM_COMBINATIONS_CHARACTERS, sep = METADATA_COLUMN_SEPARATOR))
message("Keys for metadata subsetting created. Starting for loop...")

for (CURRENT_KEY_IDX in seq_along(control_joined_keys)) {
```

# Determine the unique values for each column of a dataframe.

```{r}
final_metadata_df <- data.frame(
  sample_type = metadata_df[, 1],
  condition_idx = metadata_df[, 2],
  bam_type = metadata_df$bam_type,
  normalization_method = unlist(normalization_method),
  file_path = BIGWIG_FILES,
  stringsAsFactors = FALSE
)
# Determine unique values for each categories
message("Determining unique categories...")
metadata_columns <- setdiff(names(final_metadata_df), "file_path")
unique_categories_lst <- vector("list", length(metadata_columns))
message("Before...")
print(unique_categories_lst)
for (array_index in 1:length(metadata_columns)) {
  column_name_chr <- metadata_columns[array_index]
  print(column_name_chr)
  unique_values <- unique(final_metadata_df[, column_name_chr])
  print(unique_values)
  unique_categories_lst[[array_index]] <- unique_values
}
message("After...")
print(unique_categories_lst)
names(unique_categories_lst) <- metadata_columns
lapply(names(unique_categories_lst), function(column_name_chr){
  message(sprintf("--- Column %s ---", column_name_chr))
  #message("  ---Style 1 ---")
  #for (value in unique_categories_lst[[column_name_chr]]) {
    #pad_value <- paste0("|_ ", value)
    #print(pad_value)
  #}
  message("  --- Style 2 ---")
  collapsed_values <- paste(unique_categories_lst[[column_name_chr]], collapse = ",")
  print(collapsed_values)
  return()
})
```

# Debugging when there is a mismatch between numbers and lengths during assigment
## 2025-05-02
I have mistakenly assigned values of the wrong length multiple times. this could be turned into for loop with more explicit warning. Define array or list with the variable names, use the R functions to find variables and show the value.
```{r}
# Substitute for appropriate values
message(sprintf(
  "Lengths: sample_id=%d, file_path=%d, peaks=%d, fold_enr=%d, qval=%d, widths=%d",
  length(current_sample_id), length(xls_file_path), 
  length(peak_widths), length(xls_peak_df$fold_enrichment),
  length(xls_peak_df$qvalue), length(peak_widths)
))
```

# Creating a genomic range from a dataframe
I was doing this manually with the following:
```{r}
gr <- GenomicRanges::GRanges(
  seqnames = xls_peak_df$chromosome,
  ranges = IRanges::IRanges(
    # Convert from 0-based to 1-based: Input BED is 0-based; GRanges are 1-based. start+1L converts.
    start = xls_peak_df$start + 1L,
    end = xls_peak_df$end
  ),
  strand = "*"
  #strand = if("strand" %in% names(xls_peak_df)) xls_peak_df$strand else "*"
)

# Add metadata columns (everything except chr, start, end)
meta_cols <- setdiff(names(xls_peak_df), c("chromosome", "start", "end"))
if (length(meta_cols) > 0) {
  #message("Metadata columns:\n", paste(meta_cols, collapse=", "))
  GenomicRanges::mcols(gr) <- xls_peak_df[, meta_cols, drop = FALSE]
}
```

Turns out there is a simpler way to achieve a similar result:
```{r}
GenomicRanges::makeGRangesFromDataFrame(xls_peak_df, keep.extra.columns = TRUE)
```
Of course there is less flexibility if you want to control the columns that get added. Although you could potentially filter them before or maybe the command has additional parameters (check with ?). Remember to check by printing them out or checking mcols or nrow/length.
